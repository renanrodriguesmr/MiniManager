{% extends "base.html" %}
{% load static %}

{% block head %}
  <link rel="stylesheet" href="{% static 'round.css' %}">
  <link rel="stylesheet" href="{% static 'table.css' %}">
{% endblock %}

{% block content %}
  <h1>{{ round.name }}</h1>
  <div class="action-buttons">
    <form action="/version" method="get">
      <button href="/version" class="btn btn-primary">Voltar</button>
    </form>
    {% if round.status != "DONE" %}
      <form action="/finish_round" method="post">
          {% csrf_token %}
          <button type="sumbit" id="finish-button" class="btn btn-primary" name="round" value="{{round.id}}">Finalizar</button>
      </form>
    {% endif %}
  </div>
  <div class="round-content">
    <div class="round-result">
      <div id="status-bar" class="alert alert-primary" role="alert">Carregando...</div>
      <div class="result">
        <table class="styled-table">
          <thead>
              <tr>
                  {% for measurement in measurements %}
                  <th>{{ measurement }}</th>
                  {% endfor %}
              </tr>
          </thead>
          <tbody id="styled-table-content">
            {% for resultInstance in results %}
              {% for result in resultInstance.station %}
                <tr>
                  {% for measurement in measurements %}
                    {% if measurement == "time" %}
                      <td>{{ resultInstance.time }}</td>
                    {% else %}
                      <td>{{ result|dict_key:measurement }}</td>
                    {% endif %}
                  {% endfor %}
                </tr>
              {% endfor %}
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>
    <div class="round-graph">
      <div>
        <canvas class="chart" id="myChart"></canvas>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
  <script>
    // status message bar
    const STATUS = {
      WAITING: "WAITING",
      STARTING: "STARTING",
      IN_PROGRESS: "IN_PROGRESS",
      DONE: "DONE"
    };

    const STATUS_TO_MESSAGE = {};
    STATUS_TO_MESSAGE[STATUS.WAITING] = "Aguardando a inicialização...";
    STATUS_TO_MESSAGE[STATUS.STARTING] = "Iniciando...";
    STATUS_TO_MESSAGE[STATUS.IN_PROGRESS] = "Em andamento...";
    STATUS_TO_MESSAGE[STATUS.DONE] = "Finalizado";

    const updateStatusBar = (message) => {
      const element = document.getElementById("status-bar");
      element.innerHTML = message;
    }

    // graph
    const config = {
      type: 'scatter',
      data: {
        labels: [],
        datasets: []
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
            duration: 0, // general animation time
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                const label = context.dataset.label || '';
                return label;
              }
            }
          },
          legend: {
            display: false
          },
          datalabels: {
            color: '#2196f3',
            anchor: 'start',
            align: 'start',
            formatter: function(value, context) {
              return context.dataset.label;
            }
          },
        },
      },
    };
    
    const updateChat = (positions) => {
      labels = Object.keys(positions)
      datasets = []

      for(const label of labels){
        datasets.push({
          label,
          data: [{x: positions[label][0], y: positions[label][1]}],
          borderColor: '#2196f3',
          backgroundColor: '#2196f3',
          pointRadius: 8
        })
      }

      myChart.data = {labels, datasets};
      myChart.update();
    }

    // websocket
    const openWSConnection = (roundID) => {
      const url = `ws://${window.location.host}/ws/round/${roundID}/`;
      const chatSocket = new WebSocket(url);

      chatSocket.onmessage = wsOnMessage;
      chatSocket.onclose = wsOnClose;
    }

    const wsOnMessage = (e) => {
      const {type, value} = JSON.parse(e.data).payload;
        let status = STATUS_TO_MESSAGE[STATUS.WAITING];
        if(type == "START"){
            status = STATUS_TO_MESSAGE[STATUS.STARTING];
        }

        if(type == "UPDATE"){
            status = STATUS_TO_MESSAGE[STATUS.IN_PROGRESS];
            updateTable(value.partialResult);
            updateChat(value.positions);
        }

        if(type == "FINISH"){
          status = STATUS_TO_MESSAGE[STATUS.DONE];
          hiddenFinishButton();
        }

        updateStatusBar(status);
    }

    const wsOnClose = (e) => {
        console.error('Chat socket closed unexpectedly');
    };

    const updateTable = (newRows) => {
        for(row of newRows){
            addElementToTable(row);
        }
    }

    const generateColumn = (value) => {
      const tdnode =  document.createElement("td");
      const textnode = document.createTextNode(value);
      tdnode.appendChild(textnode);
      return tdnode;
    }

    const addElementToTable = (row) => {
        const trnode = document.createElement("tr");
        for(key of measurementsArray){
          const value = (key in row) ? row[key] : "";
          const tdnode = generateColumn(value);
          trnode.appendChild(tdnode);
        }

        table = document.getElementById("styled-table-content")
        table.insertBefore(trnode, table.firstChild);
    }
  
    hiddenFinishButton = () => {
      document.getElementById("finish-button").style.visibility = "hidden";
    }

    // ---- init -------
    const roundStatus = "{{round.status}}";
    const roundID = {{ round.id }};

    updateStatusBar(STATUS_TO_MESSAGE[roundStatus]);

    Chart.register(ChartDataLabels);
    const myChart = new Chart(
      document.getElementById('myChart'),
      config
    );

    // process measurements
    const measurementsArray = {{ measurements | safe }};

    if(roundStatus != STATUS.DONE){
      openWSConnection(roundID);
    }
  </script>
{% endblock %}