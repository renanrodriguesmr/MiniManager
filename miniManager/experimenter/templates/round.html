{% extends "base.html" %}
{% load static %}

{% block head %}
  <link rel="stylesheet" href="{% static 'round.css' %}">
{% endblock %}

{% block content %}
  <h1>{{ round.name }}</h1>
  <div class="action-buttons">
    <form action="/rounds/" method="post">
      {% csrf_token %}
      <button type="sumbit" class="btn btn-primary" name="version" value="versao 1">Reiniciar</button>
    </form>
    <form action="/finish_round" method="post">
        {% csrf_token %}
        <button type="sumbit" class="btn btn-primary">Finalizar</button>
    </form>
  </div>
  <div class="round-content">
    <div class="round-result">
      <div id="status-bar" class="alert alert-primary" role="alert">
        
      </div>
      <table class="styled-table">
        <thead>
            <tr>
                <th>time</th>
                <th>name</th>
                {% for measurement in measurements %}
                <th>{{ measurement }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody id="styled-table-content">
        </tbody>
      </table>
    </div>
    <div class="round-configuration">
      <div>
        <canvas class="chart" id="myChart"></canvas>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
  <script>
    // status message bar
    const WAITING_TO_START = "Aguardando a inicialização...";
    const STARTING = "Iniciando...";
    const RUNNING = "Em andamento...";
    const FINISHED = "Finalizado";

    statusToMessageMapping = {
      WAITING: WAITING_TO_START,
      STARTING: STARTING,
      IN_PROGRESS: RUNNING,
      DONE: FINISHED
    }

    const updateStatusBar = (message) => {
      const element = document.getElementById("status-bar");
      element.innerHTML = message;
    }

    const roundStatus = "{{round.status}}";
    updateStatusBar(statusToMessageMapping[roundStatus])

    // process measurements
    const configuredMeasurements = {{ measurements | safe }}
    const defaultMeasurements = ["time", "name"];
    const measurementsArray = defaultMeasurements.concat(configuredMeasurements);

    // create graph
    const config = {
      type: 'scatter',
      data: {
        labels: [],
        datasets: []
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
            duration: 0, // general animation time
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                const label = context.dataset.label || '';
                return label;
              }
            }
          },
          legend: {
            display: false
          },
          datalabels: {
            color: '#2196f3',
            anchor: 'start',
            align: 'start',
            formatter: function(value, context) {
              return context.dataset.label;
            }
          },
        },
      },
    };
    
    Chart.register(ChartDataLabels);
    const myChart = new Chart(
      document.getElementById('myChart'),
      config
    );

    const updateChat = (positions) => {
      labels = Object.keys(positions)
      datasets = []

      for(const label of labels){
        datasets.push({
          label,
          data: [{x: positions[label][0], y: positions[label][1]}],
          borderColor: '#2196f3',
          backgroundColor: '#2196f3',
          pointRadius: 8
        })
      }

      myChart.data = {labels, datasets};
      myChart.update();
    }


    // websocket
    const roundID = {{ round.id }}
    const url = `ws://${window.location.host}/ws/round/${roundID}/`;
    const chatSocket = new WebSocket(url);

    chatSocket.onmessage = (e) => {
        const {type, value} = JSON.parse(e.data).payload;
        let status = WAITING_TO_START;
        if(type == "START"){
            status = STARTING;
        }

        if(type == "UPDATE"){
            status = RUNNING;
            updateTable(value.partialResult);
            updateChat(value.positions);
        }

        if(type == "FINISH"){
          status = FINISHED;
        }

        updateStatusBar(status);
    };

    chatSocket.onclose = (e) => {
        console.error('Chat socket closed unexpectedly');
    };

    const updateTable = (newRows) => {
        for(row of newRows){
            addElementToTable(row);
        }
    }

    const generateColumn = (value) => {
      const tdnode =  document.createElement("td");
      const textnode = document.createTextNode(value);
      tdnode.appendChild(textnode);
      return tdnode;
    }

    const addElementToTable = (row) => {
        const trnode = document.createElement("tr");
        for(key of measurementsArray){
          const value = (key in row) ? row[key] : "";
          const tdnode = generateColumn(value);
          trnode.appendChild(tdnode);
        }

        table = document.getElementById("styled-table-content")
        table.insertBefore(trnode, table.firstChild);
    }
  </script>
{% endblock %}